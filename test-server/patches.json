[
  {
    "name": "Nico",
    "patch": "Index: Main.java\n===================================================================\n--- Main.java\n+++ Main.java\n@@ -1,1 +1,3 @@\n-public class Main {}\n\\ No newline at end of file\n+public class Main {\r\n+    \r\n+}\n\\ No newline at end of file\n"
  },
  {
    "name": "Nico",
    "patch": "Index: Main.java\n===================================================================\n--- Main.java\n+++ Main.java\n@@ -1,1 +1,62 @@\n-public class Main {}\n\\ No newline at end of file\n+package de.paul2708.execution.runner;\r\n+\r\n+import de.paul2708.execution.executor.CodeExecutor;\r\n+import de.paul2708.execution.executor.OutputObserver;\r\n+import de.paul2708.execution.executor.OutputType;\r\n+import de.paul2708.execution.executor.java.JavaCodeExecutor;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.concurrent.*;\r\n+\r\n+public class ExecutionRunner {\r\n+\r\n+    private final CodeExecutor codeExecutor;\r\n+    private final ExecutorService executorService;\r\n+    private final long timeout;\r\n+    private final TimeUnit timeoutUnit;\r\n+\r\n+    public ExecutionRunner(CodeExecutor codeExecutor, ExecutorService executorService, long timeout, TimeUnit timeoutUnit) {\r\n+        this.codeExecutor = codeExecutor;\r\n+        this.executorService = executorService;\r\n+        this.timeout = timeout;\r\n+        this.timeoutUnit = timeoutUnit;\r\n+    }\r\n+\r\n+    public ExecutionRunner(CodeExecutor codeExecutor) {\r\n+        this(codeExecutor, Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()),\r\n+                30, TimeUnit.SECONDS);\r\n+    }\r\n+\r\n+    public void run(String code, OutputObserver outputObserver) {\r\n+        Future<?> future = executorService.submit(() -> {\r\n+            try {\r\n+                codeExecutor.execute(code, outputObserver);\r\n+            } catch (IOException e) {\r\n+                outputObserver.observeOutput(\"Failed to execute code: \" + e.getMessage(), OutputType.INTERNAL_ERROR);\r\n+                e.printStackTrace();\r\n+            }\r\n+        });\r\n+\r\n+        try {\r\n+            future.get(timeout, timeoutUnit);\r\n+        } catch (TimeoutException e) {\r\n+            future.cancel(true);\r\n+            outputObserver.observeOutput(\"Failed to await execution: It took to long!\", OutputType.INTERNAL_ERROR);\r\n+        } catch (InterruptedException | ExecutionException e) {\r\n+            outputObserver.observeOutput(\"Failed to await execution: \" + e.getMessage(), OutputType.INTERNAL_ERROR);\r\n+            e.printStackTrace();\r\n+        }\r\n+    }\r\n+\r\n+    public void shutdown() {\r\n+        executorService.shutdown();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+        ExecutionRunner runner = new ExecutionRunner(new JavaCodeExecutor());\r\n+        // System.out.println(\"hey\");int a = 1 / 0;\r\n+        runner.run(\"public class Main {public static void main(String[] args){System.out.println(\\\"hey\\\");int a = 1 / 0;}}\",\r\n+                (output, type) -> System.out.println(\"Received: \" + output));\r\n+        runner.shutdown();\r\n+    }\r\n+}\n\\ No newline at end of file\n"
  }
]
